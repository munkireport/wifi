#!/usr/local/munkireport/munkireport-python3

import subprocess, re
import os
import sys
import json
import time
import platform
import base64

sys.path.insert(0, '/usr/local/munki')
sys.path.insert(0, '/usr/local/munkireport')

from munkilib import FoundationPlist
from Foundation import CFPreferencesCopyAppValue

def get_wifi_info():

    try:
        cmd = ['/usr/bin/wdutil','info']
        proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (output, unused_error) = proc.communicate()
        output = output.decode("utf-8", errors="ignore")

    except Exception as e:
        # On error, set state to unknown
        return {"state":"unknown"}

    # Check if Mac has WiFi or sharing is active
    if output == "":
        # Check if WiFi sharing is active
        if check_wifi_sharing():
            return {"state":"sharing"}
        else:
            return {"state":"no wifi"}

    # Check we the wifi is turned off
    if 'Power                : Off' in output:
        return {"state":"off"}

    info = {}
    for line in output.split("\n"):
        if "    RSSI                 : " in line:
            info['agrctlrssi'] = re.sub('[^0-9-]','', remove_all('    RSSI                 : ', line).strip())
        elif "    Noise                : " in line:
            info['agrctlnoise'] = re.sub('[^0-9-]','', remove_all('    Noise                : ', line).strip())

        elif "    Tx Rate              : " in line:
            info['lasttxrate'] = re.sub('[^0-9]','', remove_all('    Tx Rate              : ', line.split(".")[0]).strip())
        elif "    MCS Index            : " in line:
            info['mcs'] = re.sub('[^0-9]','', remove_all('    MCS Index            : ', line).strip())

        elif "    Power                : On" in line:
            if 'state' in info and info['state'] != "init":
                info['state'] = "running"

        elif "    Op Mode              : " in line:
            info['op_mode'] = remove_all('    Op Mode              : ', line.replace('STA', 'station')).strip()

        elif "    Security             : " in line:
            info['link_auth'] = remove_all('    Security             : ', line).strip()
        elif "    PHY Mode             : " in line:
            info['phy_mode'] = "802." + remove_all('    PHY Mode             : ', line).strip()
        elif "    Country Code         : " in line:
            info['country_code'] = remove_all('    Country Code         : ', line).strip()

        elif "    BSSID                : " in line and "None" not in line:
            info['bssid'] = format_mac_address(remove_all('    BSSID                : ', line).strip())
        elif "    BSSID                : " in line and "None" in line:
            info['state'] = "init" # Show that the wifi is on, but not connected
        elif "    SSID                 : " in line:
            info['ssid'] = remove_all('    SSID                 : ', line).strip()

        elif "    Guard Interval       : " in line:
            info['guardinterval'] = remove_all('    Guard Interval       : ', line).strip()
        elif "    NSS                  : " in line:
            info['nss'] = remove_all('    NSS                  : ', line).strip()
        elif "    Channel              : " in line:
            info['channel'] = remove_all('    Channel              : ', line.replace('5g', '5Ghz ').replace('2g', '2.4Ghz ').replace('6g', '6Ghz ')).strip()

    # Caclulate SNR
    if "agrctlrssi" in info and "agrctlnoise" in info:
        info["snr"] = int(info["agrctlrssi"]) - int(info["agrctlnoise"])

    return info

def get_wifi_info_legacy():

    try:
        cmd = ['/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport','-I']
        proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (output, unused_error) = proc.communicate()
        output = output.decode()

    except Exception as e:
        # On error, set state to unknown
        return {"state":"unknown"}

    # Check if Mac has WiFi or sharing is active
    if output == "":
        # Check if WiFi sharing is active
        if check_wifi_sharing():
            return {"state":"sharing"}
        else:
            return {"state":"no wifi"}

    if 'AirPort: Off' in output or 'AirPort is Off' in output:
        return {"state":"off"}

    info = {}
    for item in re.findall(r'\s*(.+): ([^\n]+)\n', output):
        key = item[0].lower().replace('.', '_').replace(' ', '_')
        info[key] = item[1].strip()
    if info.get('bssid'):
        info["bssid"] = format_mac_address(info["bssid"])
    info["x802_11_auth"] = info["802_11_auth"]

    # Caclulate SNR
    if "agrctlrssi" in info and "agrctlnoise" in info:
        info["snr"] = int(info["agrctlrssi"]) - int(info["agrctlnoise"])

    return info

def get_additional_wifi_info():

    info = {}

    try:
        cmd = ['/usr/libexec/airportd', 'info']
        proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (output, unused_error) = proc.communicate()
        output = output.decode("utf-8", errors="ignore")

        for line in output.split('\n'):
            if "Active PHY: " in line:
                info['phy_mode'] = line.replace("Active PHY: ","").strip()
            elif "Country Code: " in line:
                info['country_code'] = line.replace("Country Code: ","").strip()

    except Exception:
        pass

    return info

def get_wifi_interface():

    try:
        cmd = ['/usr/sbin/networksetup','-listallhardwareports']
        proc = subprocess.Popen(cmd, shell=False, bufsize=-1,
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (output, unused_error) = proc.communicate()

        for item in output.decode().split('Hardware Port: '):
            if 'Wi-Fi' in item or 'AirPort' in item:
                for line in item.split('\n'):
                    if 'Device: en' in line:
                        return line.replace("Device: ", "").strip()

    except Exception:
        return ""

def check_wifi_sharing():

    try:
        plist = FoundationPlist.readPlist("/Library/Preferences/SystemConfiguration/com.apple.nat.plist")
        wifi_interface = get_wifi_interface()

        if wifi_interface in plist["NAT"]["SharingDevices"]:
            return True
        else:
            return False

    except Exception:
        return False

def get_networks():

    try:

        plist = FoundationPlist.readPlist("/Library/Preferences/com.apple.wifi.known-networks.plist")
        networks_json = []

        for network in plist:
            # ssid_entry = {}
            ssid_entry = {"captive":"",
            "added_ad":"",
            "last_connected_system":"",
            "last_connected_user":"",
            "last_discovered_at":"",
            "channel":"",
            "autojoin_disabled":"",
            "temporarily_disabled":"",
            "standalone_6g":"",
            "passpoint":"",
            "personal_hotspot":"",
            "possibly_hidden_network":"",
            "roaming_profile_type":"",
            "security_type":"",
            "system_mode":"",
            "temporarily_disabled":"",
            "ssid":"",
            "channel_history":"",
            "bssid_list":"",
            "add_reason":""}
            for key in plist[network]:

                if key == "CaptiveProfile" and "CaptiveNetwork" in plist[network]["CaptiveProfile"]:
                    ssid_entry["captive"] = to_bool(plist[network]["CaptiveProfile"]["CaptiveNetwork"])


                elif key == "AddedAt":
                    ssid_entry["added_ad"] = string_to_time(plist[network][key])
                elif key == "JoinedBySystemAt":
                    ssid_entry["last_connected_system"] = string_to_time(plist[network][key])
                elif key == "JoinedByUserAt":
                    ssid_entry["last_connected_user"] = string_to_time(plist[network][key])
                elif key == "LastDiscoveredAt":
                    ssid_entry["last_discovered_at"] = string_to_time(plist[network][key])

                elif key == "PasspointSPRoamingEnabled":
                    ssid_entry["passpoint"] = to_bool(plist[network][key])

                elif key == "AutoJoinDisabled":
                    ssid_entry["autojoin_disabled"] = to_bool(plist[network][key])

                elif key == "PersonalHotspot":
                    ssid_entry["personal_hotspot"] = to_bool(plist[network][key])

                elif key == "Hidden":
                    ssid_entry["possibly_hidden_network"] = to_bool(plist[network][key])

                elif key == "Standalone6G":
                    ssid_entry["standalone_6g"] = to_bool(plist[network][key])

                elif key == "SupportedSecurityTypes":
                    ssid_entry["security_type"] = plist[network][key]
                elif key == "AddReason":
                    ssid_entry["add_reason"] = plist[network][key]

                elif key == "SystemMode":
                    ssid_entry["system_mode"] = to_bool(plist[network][key])

                elif key == "SSID":
                    ssid_entry["ssid"] = plist[network][key].decode('ascii')


                elif key == "__OSSpecific__":
                    for oss_key in plist[network]["__OSSpecific__"]:
                        if oss_key == "TemporarilyDisabled":
                            ssid_entry["temporarily_disabled"] = to_bool(plist[network]["__OSSpecific__"]["TemporarilyDisabled"])
                        elif oss_key == "RoamingProfileType":
                            ssid_entry["roaming_profile_type"] = plist[network]["__OSSpecific__"]["RoamingProfileType"]
                        elif oss_key == "ChannelHistory":
                            # Generate channel history
                            try:
                                history = []
                                for channel in plist[network]["__OSSpecific__"][oss_key]:
                                    channel_history = {}
                                    for channel_entry in channel:
                                        if channel_entry == "Channel":
                                            channel_history["channel"] = channel[channel_entry]
                                        elif channel_entry == "Timestamp":
                                            channel_history["timestamp"] = string_to_time(channel[channel_entry])
                                            # Get historical channel by comparing last connected with channel's timestamp
                                            if "JoinedBySystemAt" in plist[network] and channel[channel_entry] == plist[network]["JoinedBySystemAt"]:
                                                ssid_entry["channel"] = channel["Channel"]
                                            elif "JoinedByUserAt" in plist[network] and channel[channel_entry] == plist[network]["JoinedByUserAt"]:
                                                ssid_entry["channel"] = channel["Channel"]
                                    history.append(channel_history)
                                ssid_entry["channel_history"] = history
                            except Exception:
                                pass

                elif key == "BSSList":
                    # Generate BSSID history
                    try:
                        bssid_list = []
                        for bssid in plist[network][key]:
                            bssid_history = ""

                            for bssid_entry in bssid:
                                if "BSSID" == bssid_entry:
                                    bssid_history = bssid_history + bssid[bssid_entry]
                            bssid_list.append(bssid_history)

                        ssid_entry["bssid_list"] = ", ".join(bssid_list)
                    except Exception:
                        pass

            networks_json.append(ssid_entry)

        return {"known_networks":json.dumps(networks_json)}

    except Exception:
        return {"known_networks":""}

def get_networks_legacy():
    # This is unused and will be deleted in the furture.
    try:

        plist = FoundationPlist.readPlist("/Library/Preferences/SystemConfiguration/com.apple.airport.preferences.plist")

        # Older versions of macOS store it under a different key
        if "KnownNetworks" in plist:
            saved_networks = plist["KnownNetworks"]
        elif "RememberedNetworks" in plist:
            saved_networks = plist["RememberedNetworks"]
        else:
            return {}

        if str(saved_networks) == "{\n}":
            return {}

        if "PreferredOrder" in plist:
            perferred_oder = list(plist["PreferredOrder"])

        networks_json = []

        for item in saved_networks:

            # Process RememberedNetworks differently than KnownNetworks
            if "KnownNetworks" in plist:
                wifi_ssid = item
                for_by = saved_networks[item]
                split_by = "    };"
            elif "RememberedNetworks" in plist:
                for_by = item
                split_by = "emptysplitnystring1234567890"

            for network_entry in str(for_by).split(split_by):
                ssid_entry = {"captive":"","captive_bypass":"","channel":"","closed":"","disabled":"","last_connected":"","network_was_captive":"","passpoint":"","personal_hotspot":"","possibly_hidden_network":"","roaming_profile_type":"","sp_roaming":"","security_type":"","share_mode":"","system_mode":"","temporarily_disabled":"","user_role":"","ssid":"","channel_history":"","bssid_list":"","preferred_order":""}

                for network in network_entry.split('\n'):
                    if " = " in network:
                        key = network.split(' = ')[0].strip()

                        if key == "NetworkWasCaptive":
                            ssid_entry["network_was_captive"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "CaptiveBypass":
                            ssid_entry["captive_bypass"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "Captive":
                            ssid_entry["captive"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "Closed":
                            ssid_entry["closed"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "Disabled":
                            ssid_entry["disabled"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "LastConnected":
                            ssid_entry["last_connected"] = string_to_time(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "Passpoint":
                            ssid_entry["passpoint"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "PersonalHotspot":
                            ssid_entry["personal_hotspot"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "PossiblyHiddenNetwork":
                            ssid_entry["possibly_hidden_network"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "RoamingProfileType":
                            ssid_entry["roaming_profile_type"] = network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()
                        elif key == "SPRoaming":
                            ssid_entry["sp_roaming"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "SecurityType":
                            ssid_entry["security_type"] = network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()
                        elif key == "ShareMode":
                            ssid_entry["share_mode"] = network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()
                        elif key == "SystemMode":
                            ssid_entry["system_mode"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "TemporarilyDisabled":
                            ssid_entry["temporarily_disabled"] = to_bool(network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                        elif key == "UserRole":
                            ssid_entry["user_role"] = network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()
                        elif key == "SSIDString":
                            ssid_entry["ssid"] = network.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()
                            # Get the preferred order
                            if "PreferredOrder" in plist:
                                try:
                                    inter = 0
                                    for postition in perferred_oder:
                                        if wifi_ssid in postition:
                                            ssid_entry["preferred_order"] = inter
                                            break
                                        else:
                                            inter = inter+1
                                except Exception:
                                    pass

                        elif key == "ChannelHistory":
                            # Generate channel history
                            try:
                                history = []
                                for channel in str(saved_networks[item]["ChannelHistory"]).split('    }'):
                                    channel_history = {}
                                    for channel_entry in channel.split("\n"):
                                        if " = " in channel_entry:
                                            key = str(channel_entry).split(' = ')[0].strip()
                                            if key == "Channel":
                                                channel_history["channel"] = channel_entry.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()
                                            elif key == "Timestamp":
                                                channel_history["timestamp"] = string_to_time(channel_entry.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip())
                                                # Get historical channel by comparing last connected with channel's timestamp
                                                if network_entry.count(channel_entry.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()) == 2:
                                                    ssid_entry["channel"] = channel_history["channel"]
                                    history.append(channel_history)
                                ssid_entry["channel_history"] = history[:-1]
                            except Exception:
                                pass

                        elif key == "BSSIDList":
                            # Generate BSSID history
                            try:
                                bssid_list = []
                                for bssid in str(saved_networks[item]["BSSIDList"]).split('    }'):
                                    bssid_history = ""
                                    for bssid_entry in bssid.split("\n"):
                                        if " = " in bssid_entry:
                                            key = str(bssid_entry).replace('"', "").split(' = ')[0].strip()
                                            if key == "LEAKY_AP_BSSID":
                                                bssid_history = bssid_history + bssid_entry.split(' =')[1].replace('";', "").replace(';', "").replace(' "', "").strip()
                                    bssid_list.append(bssid_history)
                                ssid_entry["bssid_list"] = ", ".join(bssid_list[:-1])
                            except Exception:
                                pass

                networks_json.append(ssid_entry)
        return {"known_networks":json.dumps(networks_json)}

    except Exception:
        return {"known_networks":""}

def string_to_time(date_time):

    if (date_time == "0" or date_time == 0):
        return ""
    else:
        try:
            return str(int(time.mktime(time.strptime(str(date_time).replace(" +0000", ""), '%Y-%m-%d %H:%M:%S'))))
        except Exception:
            try:
                return str(int(time.mktime(time.strptime(str(date_time).replace(" +0000", ""), '%Y-%m-%dT%H:%M:%SZ'))))
            except Exception:
                return date_time

def to_bool(s):
    if s == "":
        return ""
    elif s != None and (s == True or int(s) == 1):
        return 1
    else:
        return 0

def remove_all(substr, str):
    return str.replace(substr, "")

def merge_two_dicts(x, y):
    z = x.copy()
    z.update(y)
    return z

def getDarwinVersion():
    """Returns the Darwin version."""
    darwin_version_tuple = platform.release().split('.')
    return int(darwin_version_tuple[0])

def format_mac_address(mac_address):
    mac_format = "{:0>2}:{:0>2}:{:0>2}:{:0>2}:{:0>2}:{:0>2}"
    return mac_format.format(*tuple(mac_address.split(':')))

def collect_known_networks_enabled():
    return CFPreferencesCopyAppValue('wifi_known_networks_enabled', 'MunkiReport')

def main():
    """Main"""

    # Don't process known networks if less than macOS 11 (Darwin 20), we don't support doing that anymore
    if collect_known_networks_enabled() and getDarwinVersion() > 19:
        known_networks = get_networks()
    else:
        known_networks = {}

    result = dict()

    # If less than macOS 13 (Darwin 22), use legacy method to get wifi data
    if getDarwinVersion() < 22:
        result = get_wifi_info_legacy()

        # Get additional WiFi info only if WiFi is active and connected
        if result["state"] == "running":
            result = merge_two_dicts(get_additional_wifi_info(), result)

        # Only merge in the known networks if not empty
        if known_networks != {}:
            result = merge_two_dicts(known_networks, result)
    else:
        result = merge_two_dicts(get_wifi_info(), known_networks)

    # Write wifi results to cache
    cachedir = '%s/cache' % os.path.dirname(os.path.realpath(__file__))
    output_plist = os.path.join(cachedir, 'wifi.plist')
    FoundationPlist.writePlist(result, output_plist)

if __name__ == "__main__":
    main()
